<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="前端小白有话说">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content>


    <meta name="description" content="浏览器12345678910111213141516171819201、浏览器正式的名字是Wed Broser；2、浏览器是使用HTTP协议的主要载体，如同各大邮箱使用电子邮件传输协议SMTP一...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>概念定义 | 前端小白有话说</title>


    <link rel="alternate" href="/atom.xml" title="前端小白有话说" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='微微'>
            <img src="/img/avatar2.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">前端小白有话说</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="概念定义">
            
	            概念定义
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/前端/">前端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/01/03</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器正式的名字是Wed Broser；</span><br><span class="line"></span><br><span class="line">2、浏览器是使用HTTP协议的主要载体，如同各大邮箱使用电子邮件传输协议SMTP一样；</span><br><span class="line"></span><br><span class="line">3、浏览器是多进程的，有一个主控进程，每一个tab页面都会新开一个进程(某些情况下多个tab会合并进程)；</span><br><span class="line"></span><br><span class="line">4、进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等；</span><br><span class="line"></span><br><span class="line">   1）浏览器的主进程（负责协调、主控），只有一个；</span><br><span class="line"></span><br><span class="line">   2）第三方插件进程，每种类型的插件对应一个进程，仅当使用该插件时才创建；</span><br><span class="line"></span><br><span class="line">   3）GPU进程，最多一个，用于3D绘制；</span><br><span class="line">   </span><br><span class="line">   4）浏览器渲染进程（内核），默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等；</span><br><span class="line">     注意：有时候会优化，如多个空白tab会合并成一个进程。</span><br><span class="line">     </span><br><span class="line">5、每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的；</span><br><span class="line">   它有几大类子线程：</span><br><span class="line">   GUI线程、JS引擎线程、事件触发线程、定时器线程、网络请求线程。</span><br></pre></td></tr></table></figure>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、Web服务器一般指的是网站的服务器，正式名称是Web Server；</span><br><span class="line"></span><br><span class="line">2、目前最流行的三个Web服务器是Apache、Nginx、IIS；</span><br><span class="line"></span><br><span class="line">3、服务器是网络环境中的高性能计算机，可以侦听网络上其他计算机（客户机）提交的服务请求；</span><br><span class="line"></span><br><span class="line">4、服务器也提供相应的服务，比如网页的服务、文件下载的服务、邮件的服务、视频的服务；</span><br><span class="line"></span><br><span class="line">5、客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同；</span><br><span class="line"></span><br><span class="line">6、每台服务器上都会安装处理请求的应用——web server；</span><br><span class="line"></span><br><span class="line">7、常见的web server产品有apache、nginx、IIS或Lighttpd等；</span><br><span class="line"></span><br><span class="line">8、web server担任管控的角色，结合配置文件，把不同用户发送的请求委托给服务器上处理相应请求的程序进行处理，</span><br><span class="line">然后返回后台程序处理产生的结果作为响应。</span><br></pre></td></tr></table></figure>

<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、URI：统一资源标识符；</span><br><span class="line"></span><br><span class="line">2、URL：统一资源定位符，俗称网址，是URI的一个子集；</span><br><span class="line"></span><br><span class="line">3、CDN：内容分发网络</span><br><span class="line">    1）应用了HTTP协议里的缓存和代理技术，代替源站响应客户端的请求；</span><br><span class="line">    </span><br><span class="line">    2）使用户就近获取所需内容，降低网络拥塞，提高用户访问的响应速度和命中率；</span><br><span class="line">    </span><br><span class="line">    3）CDN的关键技术主要有内容存储和分发技术。</span><br><span class="line">    </span><br><span class="line">4、WebService</span><br><span class="line">    1）一种跨编程语言和跨操作系统平台的远程调用技术；</span><br><span class="line">  </span><br><span class="line">    2）一个基于Web(HTTP)的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。</span><br><span class="line">    </span><br><span class="line">5、因特网的协议栈组成：物理层、链路层、网络层、运输层和应用层；</span><br><span class="line"></span><br><span class="line">6、OSI模型：物理层、链路层、网络层、运输层和应用层、表现层和会话层；</span><br><span class="line"></span><br><span class="line">7、运输层主要有两种传输协议：TCP和IP；</span><br><span class="line"></span><br><span class="line">8、TCP协议：传输控制协议，HTTP使用TCP协议作为通信协议，可靠保证数据不丢失；</span><br><span class="line"></span><br><span class="line">9、IP协议：主要解决的是通信双方寻址的问题。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、根据HTML解析【DOM树】，构建DOM树过程【遇到script】标签DOM树构建【暂停】，直至脚本执行完毕；</span><br><span class="line"></span><br><span class="line">2、根据CSS解析生成【CSS规则树】，解析时【js执行暂停】，直至CSS规则树就绪；</span><br><span class="line"></span><br><span class="line">3、结合DOM树和CSS规则树，生成【渲染树】；</span><br><span class="line"></span><br><span class="line">4、根据渲染树计算每一个节点的【信息】</span><br><span class="line">    布局：通过渲染对象的信息计算出每一个渲染对象的位置和尺寸；</span><br><span class="line">    回流：在布局完成后，发现某个部分变化影响布局，需要倒回去重新渲染。</span><br><span class="line"></span><br><span class="line">5、根据算好的信息【绘制】页面</span><br><span class="line">    重绘：不影响元素周围或内部布局的属性，将引起浏览器的重绘；</span><br><span class="line">    回流：某个元素的尺寸发生变化，重新计算渲染树，重新渲染。</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a>HTTP/HTTPS协议</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、HTTP是一种超文本传输协议，一个基于请求与响应模式的，无状态的，应用层的协议，常基于TCP的连接协议；</span><br><span class="line"></span><br><span class="line">2、HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范；</span><br><span class="line"></span><br><span class="line">3、HTTP一般是明文传输，HTTP协议发送的信息会被拦截、篡改，所以不要通过HTTP协议发送银行资信证明；</span><br><span class="line"></span><br><span class="line">4、为了防止信息会被拦截、篡改可以使用对称加密，收发双方都可以加密信息和解密信息，因为共用一套密码本（凯撒码）；</span><br><span class="line"></span><br><span class="line">5、对称加密的密码本如果没有安全的方式传送，也容易被劫持，这也是中间人攻击的典型案例，解决办法双方一起修改编码系统；</span><br><span class="line"></span><br><span class="line">6、所以需要另外一种更可靠的方法，非对称加密；但是非对称加密非常慢；</span><br><span class="line"></span><br><span class="line">7、鉴于此HTTPS应运而生；是在HTTP基础上增加了SSL层；</span><br><span class="line"></span><br><span class="line">8、HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输协议加密和身份认证保证了传输过着的安全；</span><br><span class="line">   </span><br><span class="line">9、HTTPS的工作原理是使用对称加密进行传输，但在传送密码本时使用非对称加密的方式；</span><br><span class="line"></span><br><span class="line">10、浏览器使用HTTP协议、电子传送协议是SMTP、端系统文件上传协议FTP、域名解析的DNS协议。</span><br></pre></td></tr></table></figure>

<h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、传输协议的加密方式分为对称加密和非对称加密；</span><br><span class="line"></span><br><span class="line">2、非对称加密用途：TLS，VPN，SSH；</span><br><span class="line"></span><br><span class="line">3、非对称加密过程（假如A给B发送信息）</span><br><span class="line">    1）A给B送一只鸽子；</span><br><span class="line">	</span><br><span class="line">    2）B给A送回鸽子，让鸽子带着一个开着锁的盒子(公钥)，B自己保管这此钥匙(私钥)；</span><br><span class="line">	</span><br><span class="line">    3）A把信放到盒子中，然后锁上，送给B；</span><br><span class="line">	</span><br><span class="line">    4）B收到盒子用钥匙打开阅读；</span><br><span class="line">	</span><br><span class="line">    注意：就是开着锁的盒子可以被劫持替换，解决办法就是获取认证机构的签名标记；</span><br><span class="line">         非对称加密非常慢。</span><br><span class="line"></span><br><span class="line">4、对称加密和非对称加密主要区别</span><br><span class="line">  【所需的密钥数量】</span><br><span class="line">  </span><br><span class="line">   1）在对称加密算法中，单个密用于加密和解密数据。只有那些有权访问数据的人才能拥有单个共享密钥；</span><br><span class="line">   </span><br><span class="line">   2）在非对称加密算法中，使用了两个密钥：一个是公用密钥，一个是私有密钥；</span><br><span class="line">   </span><br><span class="line">   3）私钥必须保密，而每个人都可以知道公钥；加密时使用公钥，解密时使用私钥；</span><br><span class="line">   </span><br><span class="line">   4）任何人都应该能够向我们发送加密数据，但是只有我们才能够解密和读取它。</span><br></pre></td></tr></table></figure>

<h2 id="网址输入"><a href="#网址输入" class="headerlink" title="网址输入"></a>网址输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、输入网址发送的事情：DNS寻址、三次握手、四次挥手</span><br><span class="line"></span><br><span class="line">2、浏览器会像DNS提供网址，DNS服务器会进行域名映射，找到访问网址的IP地址，由它来完成URL到IP地址的映射；</span><br><span class="line"></span><br><span class="line">3、然后HTTP客户端发起一个到服务端的TCP连接；将请求提交给具体的服务器；</span><br><span class="line"></span><br><span class="line">4、由服务器返回我们要的结果（以HTML编码格式返回给浏览器）；</span><br><span class="line"></span><br><span class="line">5、浏览器执行HTML编码，将结果显示在浏览器的正文；</span><br><span class="line"></span><br><span class="line">6、这就是一个浏览器发起请求和接受响应的过程。</span><br></pre></td></tr></table></figure>

<h2 id="DNS寻址"><a href="#DNS寻址" class="headerlink" title="DNS寻址"></a>DNS寻址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、域名系统（DNS）</span><br><span class="line"></span><br><span class="line">   计算机网络中的每一个端系统都有一个IP地址存在，而把IP地址转换为便于人类记忆的协议，就是DNS协议。</span><br><span class="line"></span><br><span class="line">2、DNS域名解析步骤如下</span><br><span class="line"></span><br><span class="line">    第一步：检查浏览器缓存中是否【缓存】过该域名对应的IP地址；</span><br><span class="line"></span><br><span class="line">    第二步：如果在浏览器缓存中没有找到IP，那么将继续查找【本机系统】是否缓存过IP；</span><br><span class="line"></span><br><span class="line">    第三步：向【本地域名解析服务系统】发起域名解析的请求；</span><br><span class="line"></span><br><span class="line">    第四步：向【根域名解析服务器】发起域名解析请求；</span><br><span class="line"></span><br><span class="line">    第五步：根域名服务器【返回】gTLD域名【解析服务器地址】；</span><br><span class="line"></span><br><span class="line">    第六步：向gTLD服务器【发起解析请求】；</span><br><span class="line"></span><br><span class="line">    第七步：gTLD服务器接收请求并【返回Name Server服务器】；</span><br><span class="line"></span><br><span class="line">    第八步：Name Server服务器【返回IP地址】给本地服务器；</span><br><span class="line"></span><br><span class="line">    第九步：本地域名服务器【缓存解析结果】；</span><br><span class="line"></span><br><span class="line">    第十步：【返回】解析结果给【用户】。</span><br></pre></td></tr></table></figure>

<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、HTTP的本质就是 tcp/ip请求；</span><br><span class="line"></span><br><span class="line">2、建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的；</span><br><span class="line"></span><br><span class="line">3、三次握手结束，开始发送HTTP请求报文（tcp将http长报文划分为短报文）</span><br><span class="line">    HTTP请求报文：请求行、请求头、请求体</span><br><span class="line">    请求行包括：请求方法、请求地址、http协议版本号</span><br><span class="line">    请求头包括：请求附件信息（客户端环境等）</span><br><span class="line">    请求体包括：请求参数的数据</span><br><span class="line">    </span><br><span class="line">4、经过后台（服务器）处理（MVC模式设计）后把响应返回给页面</span><br><span class="line">    HTTP响应报文：响应行、响应头、响应主体</span><br><span class="line">    响应行包括：状态码、状态码描述、http协议版本号</span><br><span class="line">    响应头包括：响应报文的附加信息</span><br><span class="line">    响应主体包括：返回的数据</span><br><span class="line">    </span><br><span class="line">5、当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</span><br><span class="line">    主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">    被动方：收到通道关闭的信息</span><br><span class="line">    被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">    主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure>

<p><img src="F:%5C%E5%BE%90%E5%BE%AE%5C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%5CBlog%5CHexo%5Csource%5Cimages%5C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.PNG" alt></p>
<h2 id="任务列队"><a href="#任务列队" class="headerlink" title="任务列队"></a>任务列队</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、JS的主要用途是与用户互动，以及操作DOM，这决定它只能是【单线程】；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、简单理解，单线程就是同个时间段只能做一件任务，完成之后才可以继续下一个任务；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果列队是因为计算量大，CPU忙不过来，倒也算了；但是更多的时候，CPU是闲置的；因为IO设备处理得很慢；例如 ajax读取网络数据；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、为了更好使用多CPU，H5提供了web Worker标准，允许js创建多线程，但是子线程受到主线程控制，而且子线程不得操作DOM；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、js设计者便想到，主线程完全可以不管IO设备，将其挂起，然后执行后面的任务；等后面的任务结束掉，在反过头来处理挂起的任务；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、既然是这样，必须要有一个【排队机制】；</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、所有的同步任务都在主线程上执行，行程一个执行栈；</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、除了【主线程】之外，还存在一个【任务列队】，只要异步任务有了运行结果，就在任务列队中植入一个时间；</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、主线程完成所有任务，就会读取列队任务，并将其执行；</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、重复上面三步；</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop【事件循环】。</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、当JS解析器执行代码，环境默认为全局，全局环境添加到执行环境中；浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里层的作用域）。</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、异步操作</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"medium"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印的顺序为 start-&gt; end-&gt;medium。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    第一步：执行第一行打印 “start”；</span></span><br><span class="line"><span class="comment">    第二步：执行 setTimeout，将其中的函数分存起来，等待时间结束后执行；</span></span><br><span class="line"><span class="comment">    第三步：执行最后一行，打印 “end”；</span></span><br><span class="line"><span class="comment">    第四部：处于空闲状态，查看暂存中，是否有可执行的函数；第五步：执行分存函数。</span></span><br><span class="line"><span class="comment">    因为 js 为单线程，也就是说 CPU 同一时间只能处理一个事务。得按顺序，一个一个处理。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h2 id="JS创建对象"><a href="#JS创建对象" class="headerlink" title="JS创建对象"></a>JS创建对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、Object构造函数</span><br><span class="line">   <span class="built_in">let</span> Obj=new Object();</span><br><span class="line">   Obj.name=<span class="string">'张三'</span>;</span><br><span class="line">   </span><br><span class="line">2、字面量</span><br><span class="line">   <span class="built_in">let</span> obj=&#123;<span class="string">'name'</span>:<span class="string">'张三'</span>&#125;;</span><br><span class="line">   </span><br><span class="line">3、工厂模式</span><br><span class="line">   <span class="keyword">function</span> createPerson(name)&#123;</span><br><span class="line">       var o = new Object();</span><br><span class="line">       o.name = name;</span><br><span class="line">       <span class="built_in">return</span> o; </span><br><span class="line">   &#125;</span><br><span class="line">   var person1 = createPerson(<span class="string">'张三'</span>);</span><br><span class="line">   </span><br><span class="line">4、构造函数模式</span><br><span class="line">   <span class="keyword">function</span> Person(name)&#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   var person1 = new Person(<span class="string">'张三'</span>);</span><br><span class="line"> </span><br><span class="line">5、原型模式</span><br><span class="line">6、组合使用构造函数+原型模式</span><br><span class="line">7、动态原型模式</span><br><span class="line">8、寄生构造函数模式</span><br><span class="line">9、稳妥构造函数模式</span><br></pre></td></tr></table></figure>

<h2 id="JS继承方式"><a href="#JS继承方式" class="headerlink" title="JS继承方式"></a>JS继承方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、继承方式有借接口继承(继承方法的签名)和实现继承(继承方法)；</span><br><span class="line"></span><br><span class="line">2、ES中函数没有签名，所以ES只支持实现继承，实现继承主要依靠原型链实现；</span><br><span class="line"></span><br><span class="line">   1）原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针constructor</span><br><span class="line">构造函数实例化的对象都包含一个指向原型对象的内部指针_proto_</span><br><span class="line">缺点：引用类型属性共享</span><br><span class="line"></span><br><span class="line">   2）借用构造函数继承，但是方法无法复用；</span><br><span class="line"></span><br><span class="line">   3）组合继承，存在属性创建两次的问题；</span><br><span class="line"></span><br><span class="line">   4）原型式继承；</span><br><span class="line"></span><br><span class="line">   5）寄生式继承；</span><br><span class="line"></span><br><span class="line">   6）寄生组合式继承，解决组合继承中属性创建两次的问题。</span><br></pre></td></tr></table></figure>

<h2 id="JS作用域"><a href="#JS作用域" class="headerlink" title="JS作用域"></a>JS作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、作用域是程序代码定义变量的区域，执行环境指的就是作用域；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、JavaScript采用词法作用域(也叫静态作用域)；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、词法作用域：函数作用域在【定义】函数时定义；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、动态作用域：函数作用域在【调用】函数时定义；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、JS有全局作用域和局部作用域；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、作用域规定如何查找变量，也就是当前执行代码对变量的访问权；</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	comsole.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 词法作用域中输出1；动态作用域输出2；所以JS输出1。</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">    1）能够读取其他函数内部变量的函数；</span><br><span class="line">	</span><br><span class="line">    2）简单的理解为定义在内部函数的函数(js中只有函数内部的子函数才能读取局部变量)。</span><br><span class="line">	</span><br><span class="line">2、用途</span><br><span class="line">    1）读取函数内部的变量；</span><br><span class="line">	</span><br><span class="line">    2）让变量值始终保持在内存中；</span><br><span class="line">	</span><br><span class="line">    3）方便调用上下文的局部变量，利于代码封装。</span><br><span class="line">	</span><br><span class="line">3、缺点</span><br><span class="line">    1）会使函数中的变量都被保存在内存中，IE可能导致内存泄漏；可在退出函数前，将不使用的变量删除；</span><br><span class="line">	</span><br><span class="line">    2）会在父元素外部，改变父元素内部变量、公共方法，把内部变量当作它的私有属性。</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、JS在创建变量(对象、字符串)时自动分配内存，并在这些变量不被使用时自动释放内存，这个过程被称为垃圾回收；</span><br><span class="line"></span><br><span class="line">2、垃圾回收机制分为引用计数垃圾回收、标记清除算法；</span><br><span class="line"></span><br><span class="line">3、垃圾回收机制的缺点是引起内存泄漏；</span><br><span class="line"></span><br><span class="line">4、在 JavaScript 引擎中有一个被称作垃圾回收器的东西在后台执行；</span><br><span class="line"></span><br><span class="line">5、它监控着所有对象的状态，并删除掉那些已经不可达的；</span><br><span class="line"></span><br><span class="line">6、定期执行以下“垃圾回收”步骤</span><br><span class="line">   1）垃圾收集器找到所有的根，并“标记”（记住）它们；</span><br><span class="line">   </span><br><span class="line">   2）然后它遍历并”标记”来自它们的所有参考；</span><br><span class="line">   </span><br><span class="line">   3）然后它遍历到标记的对象并标记他们的引用；</span><br><span class="line">   </span><br><span class="line">   4）所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象；</span><br><span class="line">   </span><br><span class="line">   5）一直这样，直到有未访问的引用（从根访问到）；</span><br><span class="line">   </span><br><span class="line">   6）没有被标记的所有对象都被删除。</span><br><span class="line">   </span><br><span class="line">7、总结</span><br><span class="line">   1）垃圾回收是自动完成的，我们不能强制执行或是阻止执行；</span><br><span class="line">   </span><br><span class="line">   2）当对象是可达状态时，它在内存中是可达的；</span><br><span class="line"></span><br><span class="line">   3）被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都无法访问。</span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、内存泄露是指new了一块内存，但无法被释放或者被垃圾回收；</span><br><span class="line"></span><br><span class="line">2、new了一个对象之后，它申请占用了一块堆内存；</span><br><span class="line"></span><br><span class="line">3、当把这个对象指针置为null时或者离开作用域导致被销毁；</span><br><span class="line"></span><br><span class="line">4、那么这块内存没有人引用它了在JS里面就会被自动垃圾回收；</span><br><span class="line"></span><br><span class="line">5、但是如果这个对象指针没有被置为null，且代码里面没办法再获取到这个对象指针了；</span><br><span class="line"></span><br><span class="line">6、那么就会导致无法释放掉它指向的内存，也就是说发生了内存泄露；</span><br><span class="line"></span><br><span class="line">7、即不再被应用需要的内存，由于某种原因，没有被归还给操作系统或进入可用内存池；</span><br><span class="line"></span><br><span class="line">8、常见的内存泄漏</span><br><span class="line">    1）全局变量（包括未被声明的变量、this创建的变量），可使用null解决；</span><br><span class="line">	</span><br><span class="line">    2）被遗忘的定时器或回调；</span><br><span class="line">	</span><br><span class="line">    3）闭包；</span><br><span class="line">	</span><br><span class="line">    4）DOM外引用。</span><br></pre></td></tr></table></figure>

<h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、类型</span><br><span class="line">    1）数据库数据缓存</span><br><span class="line">    2）服务器端缓存（代理和反向代理缓存）</span><br><span class="line">    3）浏览器端缓存</span><br><span class="line">    4）web应用层缓存</span><br><span class="line">	</span><br><span class="line">2、作用</span><br><span class="line">    1）减少网络宽带消耗</span><br><span class="line">    2）降低服务器压力</span><br><span class="line">    3）减少网络延迟，加快页面打开速度</span><br></pre></td></tr></table></figure>

<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器缓存分为强制缓存和协商缓存；</span><br><span class="line"></span><br><span class="line">2、客户端请求资源时，获取缓存流程如下：</span><br><span class="line">    1）根据请求的http header判断是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</span><br><span class="line">    2）当没有命中强缓存，客户端会发送请求到服务器；</span><br><span class="line">    3）服务器通过request header验证这个资源是否命中协商缓存(称为http验证)；</span><br><span class="line">    4）如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取；</span><br><span class="line">    5）客户端收到返回后就会从缓存中获取资源；</span><br><span class="line">	</span><br><span class="line">3、强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；</span><br><span class="line">	</span><br><span class="line">4、强缓存和协商缓存区别是，强缓存不会发送请求到服务器，但协商缓存会；</span><br><span class="line"></span><br><span class="line">5、当协商缓存也没有命中时，服务器就会将资源发送回客户端；</span><br><span class="line">    注意：强制刷新（ctrl+F5）时，直接从服务器加载，跳过强缓存和协商缓存；</span><br><span class="line">         普通刷新（F5）时，跳过强缓存，但是会检查协商缓存；</span><br><span class="line">	</span><br><span class="line">6、强缓存字段</span><br><span class="line">    Expries值，代表缓存资源的【过期时间】，为一个绝对时间的GMT格式的时间字符串；</span><br><span class="line">    Cache-Control:max-age:值，强缓存利用其max-age值来判断缓存资源的【最大生命周期】，它的值单位为秒。</span><br><span class="line">	</span><br><span class="line">7、协商缓存字段</span><br><span class="line">    Last_Modify值，为资源最后【更新时间】，随服务器response返回；</span><br><span class="line">    If-Modify-since，比较两个时间判断资源在两次请求期间【是否有过修改】，如果没有修改，则命中协商缓存；</span><br><span class="line">    ETag，表示资源内容的【唯一标识符】，随服务器response返回；</span><br><span class="line">    If-None-Match，服务器比较请求头部的If-None-Match与当前资源的ETag是否一致；</span><br><span class="line">                   判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存。</span><br></pre></td></tr></table></figure>

<h2 id="网页刷新"><a href="#网页刷新" class="headerlink" title="网页刷新"></a>网页刷新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、地址栏输入</span><br><span class="line">    1）浏览器【第一次访问】；</span><br><span class="line">    2）获取资源内容和cache-control: max-age:600，Last_Modify: Wed, 10 Aug 2013 15:32:18 GMT；</span><br><span class="line">    3）于是浏览器把资源文件【放到缓存中】，并且决定下次使用的时候直接去缓存中取了。</span><br><span class="line">    </span><br><span class="line">2、地址栏回车或转向</span><br><span class="line">    1）【最快】的获取资源方式；</span><br><span class="line">    2）浏览器发现缓存中有这个文件了，不在发送任何请求，直接去缓存中获取展现。</span><br><span class="line">	</span><br><span class="line">3、普通刷新</span><br><span class="line">    1）按下F5或者点击刷新按钮刷新页面的时候；</span><br><span class="line">    2）绕过本地缓存，浏览器去服务器看看这个文件【是否有过期】；</span><br><span class="line">    3）浏览器带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT发送一个请求；</span><br><span class="line">    4）服务器发现，这个文件在这个时间后还没修改过，直接返回304；</span><br><span class="line">    5）浏览器获取到304后就去缓存中获取资源。</span><br><span class="line">    </span><br><span class="line">4、强制刷新</span><br><span class="line">    1）按下Ctrl+F5刷新页面的时候，是客户端完成【强行更新】的操作；</span><br><span class="line">    2）告诉浏览器删除缓存中文件，去服务器请求个完整的资源文件。</span><br></pre></td></tr></table></figure>

<h2 id="存储（缓存）"><a href="#存储（缓存）" class="headerlink" title="存储（缓存）"></a>存储（缓存）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1、缓存主要可以分为：本地缓存、应用缓存和离线缓存；</span><br><span class="line"></span><br><span class="line">2、应用缓存</span><br><span class="line">    项目本身的缓存，比如一个JS对象缓存的数据；</span><br><span class="line">    或者状态管理机制如Vuex和Redux等进行应用数据存储，它们在页面刷新就会丢失；</span><br><span class="line">	</span><br><span class="line">3、离线缓存</span><br><span class="line">    应用在离线情况下也能快速访问的缓存资源；</span><br><span class="line">    这里主要讲serviceWorker，大多数浏览器已经支持serviceWorker提供离线缓存；</span><br><span class="line">	</span><br><span class="line">4、本地缓存</span><br><span class="line">    cookie、localStorage、sessionStorage；</span><br><span class="line">    三者均为浏览器提供的本地缓存，但是它们的生命周期和缓存大小有所不同；</span><br><span class="line">    cookie不存在兼容性、localStorage、sessionStorage存在兼容性；</span><br><span class="line">    cookie可以参与和服务端通信，LocalStorage和SessionStorage不能和服务端通信；</span><br><span class="line">    它们都不能跨域访问。</span><br><span class="line">   </span><br><span class="line">5、cookies   </span><br><span class="line">    每个 Web 站点能设置的 cookie 总数不能超过 20 个;</span><br><span class="line">    一个浏览器能创建的 cookie 数量最多为 300 个，每个不能超过 4KB；</span><br><span class="line">    会随请求发送到后端，所以一般只将用户登录或权限验证放在cookies中，避免影响请求传输效率；</span><br><span class="line">    </span><br><span class="line">6、LocalStorage</span><br><span class="line">    数据将一直保存在浏览器内，直到用户清除浏览器缓存数据为止；</span><br><span class="line">    localStorage存储需要手动清除浏览器的缓存；</span><br><span class="line">   </span><br><span class="line">7、SessionStorage</span><br><span class="line">    属性同LocalStorage，但当标签页被关闭时，SessionStorage也会被清除；</span><br><span class="line">    sessionStorage的生命周期是随页面窗口关闭而结束的。</span><br><span class="line">   </span><br><span class="line">8、cookies大小一般限制4kb以下，localStorage和sessionStorage大小一般均在5mb以下；</span><br></pre></td></tr></table></figure>

<h2 id="seesion和cookie"><a href="#seesion和cookie" class="headerlink" title="seesion和cookie"></a>seesion和cookie</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1、cookie的诞生</span><br><span class="line">    1）浏览器打开一个网页，用到的是HTTP协议，它是无状态的；</span><br><span class="line">    2）也就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的；</span><br><span class="line">    3）这种无状态的的好处是快速，但是有一个问题，有时我们希望几个请求的页面要有关联；</span><br><span class="line">       如：一些网页需要知道用户的状态，例如登陆，购物车等。</span><br><span class="line">    4）我在www.a.com/login.php里面登陆了，我在www.a.com/index.php 也希望是登陆状态；</span><br><span class="line">    5）但这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的；</span><br><span class="line">    6）所以，无法单纯的在index.php中读取到它在login.php中已经登陆了；</span><br><span class="line">    7）用【笨方法】这2个页面都去【查询数据库】，如果有登陆状态，就判断是登陆的了；</span><br><span class="line">    8）查询数据库的方案虽然可行，但是每次都要去查询数据库，会【造成数据库的压力】；</span><br><span class="line">    9）所以正是这种诉求，一个新的客户端存储数据方式出现了：cookie；</span><br><span class="line">    10）cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的；</span><br><span class="line">    11）只要设置它的存储路径在域名www.a.com下；</span><br><span class="line">    12）那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息；</span><br><span class="line">    13）很好的解决了在www.a.com/login.php页面登陆，也可以在www.a.com/index.php获取到这个登陆信息；</span><br><span class="line">    14）同时又不用反复去查询数据库。</span><br><span class="line">    </span><br><span class="line">2、session的诞生</span><br><span class="line">    1）虽然上述方案很不错，也很快速方便；</span><br><span class="line">    2）但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限；</span><br><span class="line">    3）最关键是用户可以是可见的，并可以随意的修改，很【不安全】；</span><br><span class="line">    4）那如何又要安全，又可以方便的全局读取信息呢？</span><br><span class="line">    5）于是，一种新的存储会话机制：session 诞生了；</span><br><span class="line">    6）session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系；</span><br><span class="line">    7）让2两个页面都能读取到这个全局的session信息；</span><br><span class="line">    8）session信息存在于服务器端，所以也就很好的解决了安全问题。</span><br><span class="line">    </span><br><span class="line">3、cookie的介绍</span><br><span class="line">    1）cookie是浏览器的一种本地存储方式，是服务器传给客户端并【保存在客户端】的一段信息；</span><br><span class="line">    2）cookie主要用于【用户信息的存储】，有大小、数量限制，可以设置有效时间；</span><br><span class="line">    3）cookie的内容可自动的在请求时传递给服务器；</span><br><span class="line">    4）一般用来帮助客户端和服务端通信的，常用来进行身份校验；</span><br><span class="line">    5）cookie当浏览器运行时，存储在 RAM 中发挥作用；</span><br><span class="line">    6）一旦用户从该网站或服务器退出，cookie 可存储在用户本地的硬盘上；</span><br><span class="line">    7）cookie 必须在 HTML 文件的内容输出之前设置； </span><br><span class="line">    </span><br><span class="line">4、session的介绍</span><br><span class="line">    1）用户登陆，服务端会生成一个session；</span><br><span class="line">    2）session中有对于用户的信息(如用户名、密码等)，然后会有一个sessionid;</span><br><span class="line">    3）sessionid相当于是服务端的这个session对应的key；</span><br><span class="line">    4）然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx；然后浏览器本地就有这个cookie；</span><br><span class="line">    5）以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br><span class="line">    6）通俗的来讲就是当一个用户通过 http访问到服务器时；</span><br><span class="line">    7）服务器会将一些 Key/Value 键值对返回给客户端浏览器；</span><br><span class="line">    8）并给这些数据加上一些限制条件；</span><br><span class="line">    9）在条件符合时这个用户下次访问这个服务器时，数据通过请求头又被完整地给带回服务器；</span><br><span class="line">    10）服务器根据这些信息来判断不同的用户。</span><br><span class="line"></span><br><span class="line">5、所以个人建议：</span><br><span class="line">    将登陆信息等重要信息存放为session；</span><br><span class="line">    其他信息如果需要保留，可以放在cookie中。</span><br><span class="line">    </span><br><span class="line">6、cookie和session的区别</span><br><span class="line">    1）cookie数据存放在客户的浏览器上，session数据放在服务器上；</span><br><span class="line">    2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session；</span><br><span class="line">    3）session会在一定时间内保存在服务器上；</span><br><span class="line">    当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</span><br><span class="line">    4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br></pre></td></tr></table></figure>

<h2 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、例如我们关注了某一个公众号，然后他对应的有新的消息就会给你推送。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、代码实现逻辑</span><br><span class="line">    <span class="number">1</span>）用数组存贮订阅者；</span><br><span class="line">  </span><br><span class="line">    <span class="number">2</span>）发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、发布者与订阅模式</span><br><span class="line">    <span class="comment">// 定义发布者</span></span><br><span class="line">    <span class="keyword">var</span> shoeObj = &#123;&#125;; </span><br><span class="line">    <span class="comment">// 缓存列表：存放订阅者回调函数</span></span><br><span class="line">    shoeObj.list = []; </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、增加订阅者</span><br><span class="line">    shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 订阅消息添加到缓存列表</span></span><br><span class="line">        shoeObj.list.push(fn); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、发布消息</span><br><span class="line">    shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.list[i++];) &#123;</span><br><span class="line">            <span class="comment">//第一个参数只是改变fn的this</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、小红订阅如下消息</span><br><span class="line">    shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color, size</span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"颜色是："</span> + color);        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"尺码是："</span> + size);</span><br><span class="line">    &#125;);</span><br><span class="line">         </span><br><span class="line"><span class="number">7</span>、小花订阅如下消息</span><br><span class="line">    shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color, size</span>) </span>&#123;     </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"再次打印颜色是："</span> + color);        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"再次打印尺码是："</span> + size);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、</span><br><span class="line">  shoeObj.trigger(<span class="string">"红色"</span>, <span class="number">40</span>);</span><br><span class="line">  shoeObj.trigger(<span class="string">"黑色"</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><table>
<thead>
<tr>
<th>编号</th>
<th>响应码</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>200</td>
<td>成功响应</td>
</tr>
<tr>
<td>2</td>
<td>204</td>
<td>请求处理成功，但是没有资源可以返回</td>
</tr>
<tr>
<td>3</td>
<td>206</td>
<td>对资源某一部分进行响应</td>
</tr>
<tr>
<td>4</td>
<td>301</td>
<td>永久成定向</td>
</tr>
<tr>
<td>5</td>
<td>302</td>
<td>临时重定向</td>
</tr>
<tr>
<td>6</td>
<td>303</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>304</td>
<td>浏览器获取到304后就去缓存中获取资源</td>
</tr>
<tr>
<td>8</td>
<td>307</td>
<td>临时重定向</td>
</tr>
<tr>
<td>9</td>
<td>400</td>
<td>请求报文中存在语法错误</td>
</tr>
<tr>
<td>10</td>
<td>401</td>
<td>发送的请求需要有通过HTTP认证的认证信息</td>
</tr>
<tr>
<td>11</td>
<td>403</td>
<td>服务器拒绝请求</td>
</tr>
<tr>
<td>12</td>
<td>404</td>
<td>服务器无法找到请求资源</td>
</tr>
<tr>
<td>13</td>
<td>500</td>
<td>服务器在执行请求时发生了错误</td>
</tr>
<tr>
<td>14</td>
<td>503</td>
<td>服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求</td>
</tr>
</tbody></table>
<h2 id="站点攻击"><a href="#站点攻击" class="headerlink" title="站点攻击"></a>站点攻击</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、SYN攻击</span><br><span class="line"></span><br><span class="line">2、CSRF攻击</span><br><span class="line">   点击安全性不明确的网站连接时，由于没有同源策略限制，它向常用的网站发起请求，相当于不法网站登录你的账号</span><br><span class="line"></span><br><span class="line">3、XSS攻击</span><br><span class="line">   有同源策略限制，但cookie为明文，一样可拿到cookie</span><br></pre></td></tr></table></figure>

<h2 id="App开发"><a href="#App开发" class="headerlink" title="App开发"></a>App开发</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">【此处App为应用，application，并非我们通常讲的手机App】</span><br><span class="line"></span><br><span class="line">App常用开发模式简介如下：</span><br><span class="line"></span><br><span class="line">1、Native App</span><br><span class="line">   传统的原生App开发模式，有iOS和aOS两大系统，需要各自语言开发各自App。</span><br><span class="line">   优点：性能和体验都是最好的。</span><br><span class="line">   缺点：开发和发布成本高。</span><br><span class="line"></span><br><span class="line">2、Web App</span><br><span class="line">   移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用；</span><br><span class="line">   一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application）对应。</span><br><span class="line">   优点：开发和发布成本最低。</span><br><span class="line">   缺点：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量。</span><br><span class="line"></span><br><span class="line">3、Hybrid App</span><br><span class="line">   混合模式移动应用，介于Web App、Native App这两者之间的App开发技术；</span><br><span class="line">   兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）</span><br><span class="line"></span><br><span class="line">   主要的原理是，由Native通过JSBridge等方法提供统一的API；</span><br><span class="line">   然后用Html+Css实现界面，JS来写逻辑，调用API；</span><br><span class="line">   最终的页面在Webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所以有跨平台效果。</span><br><span class="line"></span><br><span class="line">   优点：开发和发布都比较方便，效率介于Native App、Web App之间。</span><br><span class="line">   缺点：学习范围较广，需要原生配合。</span><br><span class="line"></span><br><span class="line">4、React Native App</span><br><span class="line">   Facebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的App开发方案RN；</span><br><span class="line">   使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。</span><br><span class="line">   如：Facebook、Youtube、Discord、QQ、百度等等。</span><br><span class="line">   </span><br><span class="line">   优点：效率体验接近Native App，发布和开发成本低于Native App。</span><br><span class="line">   缺点：学习有一定成本，且文档较少，免不了踩坑。</span><br><span class="line"></span><br><span class="line">5、Weex App</span><br><span class="line">   阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式；</span><br><span class="line">   站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源；</span><br><span class="line">   并在v2.0版本官方支持Vue.js，与RN分庭抗礼。</span><br><span class="line">   如：淘宝、天猫、阿里云、优酷、闲鱼、饿了么等。</span><br><span class="line">   </span><br><span class="line">   优点：单页开发模式效率极高，热更新发包体积小，并且跨平台性更强。</span><br><span class="line">   缺点：刚刚起步，文档欠缺；社区没有RN活跃，功能尚不健全，暂不适合完全使用Weex开发App。</span><br></pre></td></tr></table></figure>


    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2020/01/03/6Less教程/" class="pre-post btn btn-default" title='Less教程'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Less教程</span>
        </a>
    
    
        <a href="/2020/01/03/4JS归纳/" class="next-post btn btn-default" title='JS归纳'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">JS归纳</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器"><span class="toc-text">浏览器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器"><span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名词定义"><span class="toc-text">名词定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器渲染页面"><span class="toc-text">浏览器渲染页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-HTTPS协议"><span class="toc-text">HTTP/HTTPS协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密方式"><span class="toc-text">加密方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网址输入"><span class="toc-text">网址输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS寻址"><span class="toc-text">DNS寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP连接"><span class="toc-text">TCP连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务列队"><span class="toc-text">任务列队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS创建对象"><span class="toc-text">JS创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS继承方式"><span class="toc-text">JS继承方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS作用域"><span class="toc-text">JS作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web缓存"><span class="toc-text">Web缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器缓存"><span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网页刷新"><span class="toc-text">网页刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储（缓存）"><span class="toc-text">存储（缓存）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seesion和cookie"><span class="toc-text">seesion和cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发布者订阅模式"><span class="toc-text">发布者订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应码"><span class="toc-text">响应码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#站点攻击"><span class="toc-text">站点攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#App开发"><span class="toc-text">App开发</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>