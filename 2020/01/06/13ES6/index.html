<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="前端小白有话说">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content>


    <meta name="description" content="ES2015是JaveScript的下一个版本标准，第六版，最早被称为ES6，是2015.06发版的，2019年更新到ES10；
目前浏览器的JavaScript是ES5版本；
目前大多数高版本...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>ES6学习 | 前端小白有话说</title>


    <link rel="alternate" href="/atom.xml" title="前端小白有话说" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='微微'>
            <img src="/img/avatar2.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">前端小白有话说</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="ES6学习">
            
	            ES6学习
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/前端/">前端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/01/06</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p>ES2015是JaveScript的下一个版本标准，第六版，最早被称为ES6，是2015.06发版的，2019年更新到ES10；</p>
<p>目前浏览器的JavaScript是ES5版本；</p>
<p>目前大多数高版本的浏览器也支持ES6,不过只实现了ES6的部分特性和功能；</p>
<p>ES6添加了类和模块的语法，其他特性包括迭代器、箭头函数、二进制数据、静态类型数组、集合(maps、sets和weak maps)、promise、reflection和proxies；</p>
<p>rest/spread语法是ES9添加的。</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、声明与表达式</span><br><span class="line">	<span class="built_in">let</span>与const、解构赋值、Symbol</span><br><span class="line">2、内置对象</span><br><span class="line">	新增:Map与Set、Proxy与Reflect;</span><br><span class="line">	扩展:字符串、数值、对象、数组;</span><br><span class="line">3、运算符与语句</span><br><span class="line">	函数、迭代器、class类、模块</span><br><span class="line">4、异步编程</span><br><span class="line">	Promise对象、Generator函数、async函数(不属于ES6)</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1、ES6推荐使用<span class="built_in">let</span>代替var，并且<span class="built_in">let</span>允许创建块级作用域，不能重复声明</span><br><span class="line">var a = 2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> a = 3;</span><br><span class="line">    console.log(a); // 3</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 2</span><br><span class="line">2、<span class="built_in">let</span>声明的变量存在暂时性死区，用来描述变量不提升的现象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        console.log(a)//TDZ，俗称临时死区</span><br><span class="line">        <span class="built_in">let</span> a = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>()  // a is not defined</span><br><span class="line">正确的使用方法：先声明，再访问。</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">let</span> a = 1</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>() // 1</span><br><span class="line">3、ES6推荐使用const声明常量并初始化赋值，同样在块级作用域有效，不能重复声明</span><br><span class="line">&#123;</span><br><span class="line">    const ARR = [5,6];</span><br><span class="line">    ARR.push(7);</span><br><span class="line">    console.log(ARR); // [5,6,7]</span><br><span class="line">    ARR = 10; // TypeError</span><br><span class="line">&#125;</span><br><span class="line">const不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。</span><br><span class="line">const <span class="built_in">type</span> = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">type.a = 2 //没有直接修改<span class="built_in">type</span>的值，而是修改type.a的属性值，这是允许的。</span><br><span class="line">console.log(<span class="built_in">type</span>) // &#123;a: 2&#125;</span><br><span class="line">注意：当使用常量 const 声明时，请使用大写变量</span><br></pre></td></tr></table></figure>

<h2 id="对象新增方法——词法扩展"><a href="#对象新增方法——词法扩展" class="headerlink" title="对象新增方法——词法扩展"></a>对象新增方法——词法扩展</h2><p>允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getCar(make, model, value) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        make,  // 等同于 make: make</span><br><span class="line">        model, // 等同于 model: model</span><br><span class="line">        value, // 等同于 value: value</span><br><span class="line">        [<span class="string">'make'</span> + make]: <span class="literal">true</span>,// 属性可以使用表达式计算值</span><br><span class="line">        <span class="function"><span class="title">depreciate</span></span>() &#123;	// 忽略 `<span class="keyword">function</span>` 关键词简写对象函数</span><br><span class="line">            this.value -= 2500;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output: &#123;</span><br><span class="line">    // make: <span class="string">'Barret'</span>,</span><br><span class="line">    // model:<span class="string">'Lee'</span>,</span><br><span class="line">    // value: 40000,</span><br><span class="line">    // makeBarret: <span class="literal">true</span>,</span><br><span class="line">    // depreciate: <span class="keyword">function</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象新增方法——解构赋值"><a href="#对象新增方法——解构赋值" class="headerlink" title="对象新增方法——解构赋值"></a>对象新增方法——解构赋值</h2><p>避免在对象赋值时产生中间变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> [1,2,3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = foo(); // [1,2,3]</span><br><span class="line"><span class="built_in">let</span> [a, b, c] = foo();</span><br><span class="line">console.log(a, b, c); // 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        x: 4,</span><br><span class="line">        y: 5,</span><br><span class="line">        z: 6</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> &#123;x: x, y: y, z: z&#125; = bar();</span><br><span class="line">console.log(x, y, z); // 4 5 6</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> p1 = 1;</span><br><span class="line"><span class="built_in">let</span> p2 = 2;</span><br><span class="line">[p1,p2] = [p2, p1];</span><br><span class="line">console.log(p1);//2</span><br><span class="line">console.log(p2);//1</span><br></pre></td></tr></table></figure>

<p>删除不需要的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; _internal, tooBig, …cleanObject &#125; = &#123;</span><br><span class="line">	el1:’1’,</span><br><span class="line">	_internal:’secret’,</span><br><span class="line">	tooBig:&#123;&#125;,</span><br><span class="line">	el2:’2’,</span><br><span class="line">	el3:’3’</span><br><span class="line">&#125;</span><br><span class="line">Console.log(cleanObject);  //&#123;el1:’1’,el2:’2’,el3:’3’3&#125;</span><br></pre></td></tr></table></figure>

<p>在函数参数中解构嵌套对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var car = &#123;</span><br><span class="line">    model: <span class="string">"bmw 2018"</span>,</span><br><span class="line">    engine: &#123;</span><br><span class="line">        v6: <span class="literal">true</span>,</span><br><span class="line">        turbo: <span class="literal">true</span>,</span><br><span class="line">        vin: 12345</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const modelAndVin = (&#123;model, engine: &#123;vin&#125;&#125;) =&gt; &#123;</span><br><span class="line">    console.log(`model: <span class="variable">$&#123;model&#125;</span> vin: <span class="variable">$&#123;vin&#125;</span>`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelAndVIN(car);//model: bmw 2018 vin:12345</span><br></pre></td></tr></table></figure>

<h2 id="对象新增方法——Object-assign"><a href="#对象新增方法——Object-assign" class="headerlink" title="对象新增方法——Object.assign()"></a>对象新增方法——Object.assign()</h2><p>拷贝源对象自身可枚举的属性到目标对象;返回目标对象,源对象也会改变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、合并对象</span><br><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line">var obj = Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">2、合并具有相同属性的对象</span><br><span class="line">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h2><p>find()、findIndex()、fill()、copyWithin()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1、Array.isArray()数组类型判断 </span><br><span class="line">Array.isArray([])//<span class="literal">true</span></span><br><span class="line">2、find()//找到数组中符合当前搜索规则的第一个元素</span><br><span class="line">const arr = [1, <span class="string">"2"</span>, 3, 3, <span class="string">"2"</span>]</span><br><span class="line">console.log(arr.find(item =&gt; typeof item === <span class="string">"number"</span>)) // 1</span><br><span class="line"></span><br><span class="line">3、findIndex()//找到数组中符合当前搜索规则的第一个元素，返回它的索引</span><br><span class="line">const arr = [1, <span class="string">"2"</span>, 3, 3, <span class="string">"2"</span>]</span><br><span class="line">console.log(arr.findIndex(item =&gt; typeof item === <span class="string">"number"</span>)) // 0</span><br><span class="line"></span><br><span class="line">4、fill()//用新元素替换掉数组内的元素，可以指定替换下标范围</span><br><span class="line">arr.fill(value, start, end)</span><br><span class="line"></span><br><span class="line">5、copyWithin()//选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围</span><br><span class="line">arr.copyWithin(target, start, end)</span><br><span class="line"></span><br><span class="line">1)const arr = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从索引为3的元素开始，复制数组，所以4, 5被替换成1, 2</span><br><span class="line"></span><br><span class="line">2)const arr1 = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从索引为3的元素开始复制数组，复制的第一个元素索引为1，所以4, 5被替换成2, 3</span><br><span class="line"></span><br><span class="line">const arr2 = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从索引为3的元素开始复制数组，指定复制的第一个元素索引为1，结束位置为2，所以4被替换成2</span><br></pre></td></tr></table></figure>

<h2 id="Spread-Rest-操作符"><a href="#Spread-Rest-操作符" class="headerlink" title="Spread / Rest 操作符"></a>Spread / Rest 操作符</h2><p>Spread / Rest 操作符指的是 …,具体是 Spread 还是 Rest 需要看上下文语境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、当被用于迭代器中时，它是一个 Spread 操作符</span><br><span class="line"><span class="keyword">function</span> foo(x,y,z) &#123;</span><br><span class="line">    console.log(x,y,z);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">foo(...arr); // 1 2 3</span><br><span class="line">2、当被用于函数传参时，是一个 Rest 操作符</span><br><span class="line"><span class="keyword">function</span> foo(...args) &#123;</span><br><span class="line">    console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]</span><br><span class="line">3、合并对象</span><br><span class="line"><span class="built_in">let</span> object1 = &#123;a:1,b:2,c:3&#125;</span><br><span class="line"><span class="built_in">let</span> object2 = &#123;b:30, c:40, d:50&#125;</span><br><span class="line"><span class="built_in">let</span> merged = &#123;...object1, ...object2&#125;</span><br><span class="line">console.log(merged)//&#123;a:1, b:30, c:40, d:50&#125;</span><br><span class="line">4、平铺嵌套多维数组</span><br><span class="line"><span class="keyword">function</span> flattenArray(arr) &#123;</span><br><span class="line">    const flattened = [].concat(...arr);</span><br><span class="line">    <span class="built_in">return</span> flattened.some(item =&gt; Array.isArray(item))?flattenArray(flattened):flattened;</span><br><span class="line">&#125;</span><br><span class="line">const arr = [11,[22,33],[44,[55,66,[77,[88]],99]]];</span><br></pre></td></tr></table></figure>

<h2 id="新增字符串方法——模板字符串"><a href="#新增字符串方法——模板字符串" class="headerlink" title="新增字符串方法——模板字符串"></a>新增字符串方法——模板字符串</h2><p>ES6 中有一种十分简洁的方法组装一堆字符串和变量，可换行、可以用${}来表示模板占位符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> user = <span class="string">'Barret'</span>;</span><br><span class="line">console.log(`Hi <span class="variable">$&#123;user&#125;</span>!`); // Hi Barret!</span><br><span class="line"><span class="variable">$&#123; ... &#125;</span> 用来渲染一个变量; ` 作为分隔符。</span><br></pre></td></tr></table></figure>

<h2 id="新增字符串方法"><a href="#新增字符串方法" class="headerlink" title="新增字符串方法"></a>新增字符串方法</h2><p>ES6强制使用UTF-16字符串编码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、codePointAt()</span><br><span class="line">2、String.fromCodePoiont()</span><br><span class="line">3、normalize()</span><br><span class="line">4、includes(str, index)</span><br><span class="line">如果在字符串中检测到指定文本，返回<span class="literal">true</span>，否则<span class="literal">false</span>。</span><br><span class="line"><span class="built_in">let</span> t = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">if</span>(t.includes(<span class="string">'cde'</span>)) &#123;</span><br><span class="line">    console.log(2)//<span class="literal">true</span></span><br><span class="line">&#125;	</span><br><span class="line">5、startsWith(str, index)</span><br><span class="line">如果在字符串起始部分检测到指定文本，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="built_in">let</span> t = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">if</span>(t.startsWith(<span class="string">'ab'</span>)) &#123;</span><br><span class="line">    console.log(2)//<span class="literal">true</span></span><br><span class="line">&#125;	</span><br><span class="line">6、endsWith(str, index)</span><br><span class="line">如果在字符串的结束部分检测到指定文本，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="built_in">let</span> t = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">if</span>(t.endsWith(<span class="string">'fg'</span>)) &#123;</span><br><span class="line">    console.log(2)//<span class="literal">true</span></span><br><span class="line">&#125;	</span><br><span class="line">如果你只是需要匹配字符串中是否包含某子字符串，那么推荐使用新增的方法</span><br><span class="line">如果需要找到匹配字符串的位置，使用indexOf()。</span><br></pre></td></tr></table></figure>

<h2 id="for…of-VS-for…in"><a href="#for…of-VS-for…in" class="headerlink" title="for…of VS for…in"></a>for…of VS for…in</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、for...of 用于遍历一个迭代器，如数组：</span><br><span class="line"><span class="built_in">let</span> nicknames = [<span class="string">'di'</span>, <span class="string">'boo'</span>, <span class="string">'punkeye'</span>];</span><br><span class="line">nicknames.size = 3;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> nickname of nicknames) &#123;</span><br><span class="line">	console.log(nickname);// 结果: di, boo, punkeye	</span><br><span class="line">&#125;</span><br><span class="line">2、for...in 用来遍历对象中的属性：</span><br><span class="line"><span class="built_in">let</span> nicknames = [<span class="string">'di'</span>, <span class="string">'boo'</span>, <span class="string">'punkeye'</span>];</span><br><span class="line">nicknames.size = 3;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> nickname <span class="keyword">in</span> nicknames) &#123;</span><br><span class="line">	console.log(nickname);// 0, 1, 2, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制和八进制的字面量"><a href="#二进制和八进制的字面量" class="headerlink" title="二进制和八进制的字面量"></a>二进制和八进制的字面量</h2><p>ES6通过在数字前面添加 0o 或者0O 即可将其转换为八进制值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> oValue = 0o10;</span><br><span class="line">console.log(oValue); // 8</span><br><span class="line"><span class="built_in">let</span> bValue = 0b10; // 二进制使用 `0b` 或者 `0B`</span><br><span class="line">console.log(bValue); // 2</span><br></pre></td></tr></table></figure>

<h2 id="对象超类"><a href="#对象超类" class="headerlink" title="对象超类"></a>对象超类</h2><p>ES6 允许在对象中使用 super 方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">	<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">		console.log(<span class="string">"Hello from the Parent"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var child = &#123;</span><br><span class="line">	<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">		super.foo();</span><br><span class="line">			console.log(<span class="string">"Hello from the Child"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(child, parent);</span><br><span class="line">child.foo(); // Hello from the Parent</span><br><span class="line">             // Hello from the Child</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>ES6 中有 class 语法，class 不是新的对象继承模型，它只是原型链的语法糖表现形式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在类中定义函数不需要使用 <span class="keyword">function</span> 关键词</span><br><span class="line">函数中使用 static 关键词定义构造函数的的方法和属性</span><br><span class="line">class Task &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"task instantiated!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showId</span></span>() &#123;</span><br><span class="line">        console.log(23);</span><br><span class="line">    &#125;</span><br><span class="line">    static <span class="function"><span class="title">loadAll</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"Loading all tasks.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Task); // <span class="keyword">function</span></span><br><span class="line"><span class="built_in">let</span> task = new Task(); // <span class="string">"task instantiated!"</span></span><br><span class="line">task.showId(); // 23</span><br><span class="line">Task.loadAll(); // <span class="string">"Loading all tasks.."</span></span><br><span class="line">类的声明不会提升，如果使用某个 Class，先定义它在使用，否则会抛出ReferenceError错误</span><br><span class="line">与ES5一样，在Class内部可以使用get和<span class="built_in">set</span>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</span><br><span class="line">取值函数（getter）和存值函数（setter）</span><br></pre></td></tr></table></figure>

<h2 id="类中超集super和继承extends"><a href="#类中超集super和继承extends" class="headerlink" title="类中超集super和继承extends"></a>类中超集super和继承extends</h2><p>ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"Creating a new car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Porsche extends Car &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">        console.log(<span class="string">"Creating Porsche"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">let</span> c = new Porsche();// Creating a new car</span><br><span class="line">                      // Creating Porsche</span><br><span class="line">extends 允许子类继承父类，但子类的constructor 函数中需要执行 super() 函数</span><br><span class="line">可以在子类方法中调用父类的方法，如super.parentMethodName()</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;    <span class="built_in">return</span> this.color + <span class="string">' '</span> + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promise 是一个等待被异步执行的对象，本质是对回调函数的封装<br>回调函数很容易形成回调函数的嵌套,形成回调地狱；当业务逻辑更复杂时，嵌套N层后，代码将很难维护！<br>Promise对象存在三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）、Rejected(已失败)<br>新建一个Promise后，Promise的初始状态就是Pending；<br>当它执行完成后，状态由Pending变为Fulfilled或者Rejected，且状态改变之后不会在发生变化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (/* 条件语句 */) &#123;</span><br><span class="line">        //成功</span><br><span class="line">        resolve(/* value */);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 失败</span><br><span class="line">        reject(/* reason */);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">new Promise()接受一个函数作为参数,此函数有两个参数，这两个参数也是两个方法</span><br><span class="line">p.then(</span><br><span class="line">    (val) =&gt; console.log(<span class="string">"Promise Resolved"</span>, val),</span><br><span class="line">    (err) =&gt; console.log(<span class="string">"Promise Rejected"</span>, err)</span><br><span class="line">);</span><br><span class="line">每一个 Promise 都有一个.<span class="keyword">then</span> 方法，这个方法接受两个参数</span><br><span class="line">第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调</span><br><span class="line"><span class="keyword">then</span>()方法可以被同一个Promise对象多次调用</span><br><span class="line"><span class="keyword">then</span>()方法必须返回一个新的Promise对象，因此Promise支持链式调用</span><br><span class="line"></span><br><span class="line">如何使用promise如何避免回调函数的嵌套呢，一般promise要和async+await配套使用</span><br><span class="line">Const fs = require(‘fs’);</span><br><span class="line">Function myReadFile（file）&#123;</span><br><span class="line">	<span class="built_in">return</span> new Promise(<span class="keyword">function</span>(accept,reject) &#123;</span><br><span class="line">		fs.readFile(file,<span class="keyword">function</span>(err,data)&#123;</span><br><span class="line">				<span class="keyword">if</span>(err) &#123;reject(err)&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(data) &#123;console.log(data);accept(data);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">Async <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">	Await myReadFile (“fileA”)</span><br><span class="line">Await myReadFile (“fileB”)</span><br><span class="line">Await myReadFile (“fileC”)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>()</span><br><span class="line">await myReadFile(<span class="string">"fileA"</span>)，表示当fileA没有读取完毕，就一直<span class="built_in">wait</span>，直到fileA读取完毕，只有fileA读取完毕后，才会执行await  myReadFile(<span class="string">"fileB"</span>)；</span><br><span class="line">同理，只有fileB读取完毕后，才会执行await  myReadFile(<span class="string">"fileC"</span>)；</span><br><span class="line">await内部是如何实现等待或继续执行的功能呢？</span><br><span class="line">JS的本质是靠一个单线程的事件循环，不停的从任务队列中取出任务并执行，当JS的事件循环执行到await时，会检查Promise的状态，</span><br><span class="line">•	当发现状态是Pending，就暂停当前任务的执行（即不执行await后面的代码，虽然await后面的代码被阻塞了，但是事件循环并不会阻塞，它会继续循环，执行任务队列中的其他任务，这样不浪费CPU，这也是JS实现异步函数的原理）</span><br><span class="line">•	当发现状态是Rejected或者Resolved，说明Promise已经执行完毕，就继续执行当前任务（即await后面的代码）</span><br><span class="line">综上所述，JS的事件循环，不停的获取Promise的状态，根据状态的不同，决定等待还是继续执行，这其实就是个状态机啦。</span><br></pre></td></tr></table></figure>

<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><p>Generator函数使用 * 语法和关键词yield,返回的可遍历对象生成多个值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">infiniteNumbers</span></span>() &#123;</span><br><span class="line">	var n = 1;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		yield n++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var numbers = infiniteNumbers(); // returns an iterable object</span><br><span class="line">numbers.next(); // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">numbers.next(); // &#123; value: 2, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">numbers.next(); // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">每次执行 yield 时，返回的值变为迭代器的下一个值。</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体：</span><br><span class="line">var getPrice = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	<span class="built_in">return</span> 4.55;</span><br><span class="line">&#125;;</span><br><span class="line">var getPrice = () =&gt; 4.55//此箭头函数采用了简洁函数体，它不需要 <span class="built_in">return</span> 语句</span><br><span class="line">2、允许你对函数参数设置默认值</span><br><span class="line">	<span class="built_in">let</span> getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;</span><br><span class="line">	getFinalPrice(500); // 850	</span><br><span class="line">3、与普通函数区别</span><br><span class="line">	普通函数：</span><br><span class="line">		1）函数作为全局函数被调用时，this指向全局对象</span><br><span class="line">		2）函数作为对象中的方法被调用时，this指向该对象</span><br><span class="line">		3）函数作为构造函数的时候，this指向构造函数new出来的新对象</span><br><span class="line">		4）还可以通过call，apply，<span class="built_in">bind</span>改变this的指向</span><br><span class="line">	箭头函数：</span><br><span class="line">		1）箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。</span><br><span class="line">           箭头函数的this是和定义时有关和调用无关。</span><br><span class="line">		2）箭头函数没有super</span><br><span class="line">		3）箭头函数没有arguments</span><br><span class="line">		4）箭头函数没有new.target绑定。</span><br><span class="line">		5）箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误。</span><br><span class="line">		6）没有原型</span><br><span class="line">		7）不支持重复的命名参数。</span><br></pre></td></tr></table></figure>

<h2 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1、entries() 返回迭代器——返回键值对</span><br><span class="line">const arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.entries()) &#123;</span><br><span class="line">	console.log(v)// [0, <span class="string">'a'</span>] [1, <span class="string">'b'</span>] [2, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.entries()) &#123;</span><br><span class="line">	console.log(v)// [<span class="string">'a'</span>, <span class="string">'a'</span>] [<span class="string">'b'</span>, <span class="string">'b'</span>] [<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Map();</span><br><span class="line">arr.set(<span class="string">'a'</span>, <span class="string">'a'</span>);</span><br><span class="line">arr.set(<span class="string">'b'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.entries()) &#123;</span><br><span class="line">	console.log(v)// [<span class="string">'a'</span>, <span class="string">'a'</span>] [<span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、values() 返回迭代器——返回键值对的value</span><br><span class="line">const arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.values()) &#123;</span><br><span class="line">  console.log(v)//<span class="string">'a'</span> <span class="string">'b'</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.values()) &#123;</span><br><span class="line">	console.log(v)// <span class="string">'a'</span> <span class="string">'b'</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Map();</span><br><span class="line">arr.set(<span class="string">'a'</span>, <span class="string">'a'</span>);</span><br><span class="line">arr.set(<span class="string">'b'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.values()) &#123;</span><br><span class="line">	console.log(v)// <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、keys() 返回迭代器——返回键值对的key</span><br><span class="line">const arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.keys()) &#123;</span><br><span class="line">	console.log(v)// 0 1 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.keys()) &#123;</span><br><span class="line">	console.log(v)// <span class="string">'a'</span> <span class="string">'b'</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new Map();</span><br><span class="line">arr.set(<span class="string">'a'</span>, <span class="string">'a'</span>);</span><br><span class="line">arr.set(<span class="string">'b'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr.keys()) &#123;</span><br><span class="line">	console.log(v)// <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>以前数据类型：基本数据类型(Undefined，Null，Boolean，Number、String) + 引用类型Object<br>S6中提出的新数据类型,名叫symbol，它的值是唯一不可变的，但访问不到；目的是为了生成一个唯一的标识符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以通过调用 Symbol() 方法将创建一个新的 Symbol 类型的值，不能使用 new 操作符</span><br><span class="line">var sym = Symbol( <span class="string">"some optional description"</span> );</span><br><span class="line">console.log(typeof sym); // symbol</span><br><span class="line">如果被用作一个对象的属性，那么这个属性会是不可枚举的</span><br><span class="line">var o = &#123;</span><br><span class="line">    val: 10,</span><br><span class="line">    [ Symbol(<span class="string">"random"</span>) ]: <span class="string">"I'm a symbol"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.getOwnPropertyNames(o)); // val</span><br><span class="line">如果要获取对象 symbol 属性，需要使用Object.getOwnPropertySymbols(o)</span><br></pre></td></tr></table></figure>

<h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><p>都叫做集合</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Array和Set对比</span><br><span class="line">都是一个存储多值的容器，两者可以互相转换</span><br><span class="line">Set不含有重复值（可以利用这个特性实现对一个数组的去重）</span><br><span class="line">Array的很多新方法map、filter、some、every等是Set没有的</span><br><span class="line">Set使用展开运算符得到数组，可以对Set使用Array的所有原生方法</span><br><span class="line">Set通过delete方法删除某个值，而Array只能通过splice，Set更方便</span><br><span class="line">Set的has方法效率比Array的indexOf方法高</span><br><span class="line">2、Object和Map对比</span><br><span class="line">Object是字符串-值，Map是值-值</span><br><span class="line">Object键为string类型,Map的键是任意类型</span><br></pre></td></tr></table></figure>

<h2 id="Set和WeakSet"><a href="#Set和WeakSet" class="headerlink" title="Set和WeakSet"></a>Set和WeakSet</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Map-和-WeakMap"><a href="#Map-和-WeakMap" class="headerlink" title="Map 和 WeakMap"></a>Map 和 WeakMap</h2><p>新的数据结构集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用是指在函数return的时候调用一个新的函数；如果在一个循环体中，存在函数的尾调用，你的内存可能爆满或溢出，因为尾调用的实现需要存储到内存中。尾调用实际用途是递归函数优化，ES6中引擎会做好尾调用的优化工作，不需要自己优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">需要满足下面3个要求：</span><br><span class="line">1、函数不是闭包</span><br><span class="line">2、尾调用是函数最后一条语句</span><br><span class="line">3、尾调用结果作为函数返回</span><br><span class="line">递归会影响性能，但是尾调用优化之后，递归函数的性能有了提升</span><br><span class="line">//新型尾优化写法</span><br><span class="line"><span class="string">"use strict"</span>;  </span><br><span class="line"><span class="keyword">function</span> a(n, p = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= 1) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1 * p</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> s = n * p</span><br><span class="line">  <span class="built_in">return</span> a(n - 1, s)</span><br><span class="line">&#125;</span><br><span class="line">//求 1 x 2 x 3的阶乘</span><br><span class="line"><span class="built_in">let</span> sum = a(3)</span><br><span class="line">console.log(sum) // 6</span><br></pre></td></tr></table></figure>


    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2020/01/09/15电脑快捷键/" class="pre-post btn btn-default" title='电脑快捷键'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">电脑快捷键</span>
        </a>
    
    
        <a href="/2020/01/06/11bootstrap-datetimepicker/" class="next-post btn btn-default" title='bootstrap-datetimepicker基本使用'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">bootstrap-datetimepicker基本使用</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#大纲"><span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象新增方法——词法扩展"><span class="toc-text">对象新增方法——词法扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象新增方法——解构赋值"><span class="toc-text">对象新增方法——解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象新增方法——Object-assign"><span class="toc-text">对象新增方法——Object.assign()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组新增方法"><span class="toc-text">数组新增方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spread-Rest-操作符"><span class="toc-text">Spread / Rest 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新增字符串方法——模板字符串"><span class="toc-text">新增字符串方法——模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新增字符串方法"><span class="toc-text">新增字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for…of-VS-for…in"><span class="toc-text">for…of VS for…in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二进制和八进制的字面量"><span class="toc-text">二进制和八进制的字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象超类"><span class="toc-text">对象超类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类中超集super和继承extends"><span class="toc-text">类中超集super和继承extends</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promises"><span class="toc-text">Promises</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generators"><span class="toc-text">Generators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器（Iterators）"><span class="toc-text">迭代器（Iterators）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map和Set"><span class="toc-text">Map和Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set和WeakSet"><span class="toc-text">Set和WeakSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-和-WeakMap"><span class="toc-text">Map 和 WeakMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尾调用优化"><span class="toc-text">尾调用优化</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>